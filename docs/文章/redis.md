# Redis 面试题

## 数据结构

### Redis 数据结构有哪些？

Redis 常见的有 5 种数据结构：

1. String（字符串）：SDS。缓存对象、常规计数、分布式锁、共享 session 等
2. Hash（哈希）：压缩列表或哈希表 -> listpack。缓存对象、购物车
3. List（列表）：双向链表和压缩列表 -> quicklist。消息队列
   - 问题 1：生产者需要自行实现全局唯一 ID
   - 问题 2：不能以消费组形式消费数据
4. Set（集合）：哈希表或整数集合。聚合计算（交集、并集、差集），点赞、共同关注、抽奖
5. ZSet（有序集合）：压缩列表或跳表 -> listpack。排序场景，比如排行榜、电话和姓名等

后面新增了 4 种：BitMap（2.2 版新增）、HyperLogLog（2.8 版新增）、GEO（3.2 版新增）、Stream（5.0 版新增）。

### 用什么结构实现延迟消息队列？

常见延迟消息场景：

- 淘宝购物车未付款订单 24 小时后自动取消
- 打车时长时间没有车主接单，平台取消订单并告诉你暂时没有车主接单
- 点外卖时，如果商家 10 分钟还没有接单，就会自动取消接单

可以使用有序集合 ZSet 的方式来实现延迟队列，ZSet 有一个 Score 属性可以用来存储延迟执行的时间。

使用 `add score1 value1` 就可以一直向内存中生产消息，再利用 zrangebyscore 查询所有符合条件的所有待处理任务，通过循环执行队列任务即可。

## 高可用

### 缓存雪崩是什么？如何解决？

缓存雪崩是指大量请求不经过缓存，直接查询数据库，导致数据库压力骤增，进而发生宕机等故障，从而造成连锁反应，造成整个系统崩溃。

造成缓存雪崩的原因和解决办法：

- 大量缓存同时过期，缓存都未命中
	- 设置均匀过期时间：如果要给缓存设置过期时间，尽量避免将大量的数据设置为同一个过期时间。可以在设置缓存时间时，给过期时间添加一个随机数，这样就保证数据不会在同一时间过期
	- 互斥锁：当业务线程在处理用户请求时，如果发现访问的数据不在 Redis 里，就加一个互斥锁，保证同一时间只能有一个请求在构建缓存（从数据库读取数据，再将数据更新到 Redis 里），当缓存构建完成后再释放锁。未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么直接返回空值或默认值
	- 后台更新缓存：业务线程不再负责更新缓存，缓存也不设置有效期，让缓存”永久有效“，并将更新缓存的工作由后台线程实时更新
- redis 故障
	- 熔断机制：直接启用服务的熔断机制，暂停业务方对缓存服务的访问，直接返回错误，不再继续访问数据库，从而降低对数据库的访问压力，保证数据库系统的正常运行，等 Redis 恢复正常后，再允许业务应用访问缓存服务。熔断机制保护了数据库的正常访问，但是暂停了业务访问缓存。
	- 构建 Redis 缓存高可用集群：通过主从节点的方式构建 Redis 缓存高可用集群。如果 Redis 缓存的主节点故障宕机，从节点可以切换为主节点，继续提供缓存服务，避免了由于 Redis 故障宕机从而导致的缓存雪崩问题

### 多级缓存如何保证数据一致性？

- 方案一：通过 redis 过期时间更新缓存，MySQL 数据库更新不会触发 redis 更新，只有当 redis key 过期后才会重新加载
	- 缺点 1：数据不一致的时间较长，会造成脏数据
	- 缺点 2：完全依赖过期时间，过期时间太短缓存更新太频繁，太长容易有长时间的更新延迟
- 方案二：在方案一的基础上，用 key 的过期时间做兜底，在更新 MySQL 的同时也会更新 redis。
	- 缺点：如果 MySQL 更新成功，redis 更新失败，则会出现和方案一一样的问题
- 方案三：在方案二的基础上，使用消息队列，异步更新 redis
	- 缺点 1：解决不了时序的问题，如果多个业务实例同时更新同一条数据，数据更新的先后顺序可能会乱
	- 缺点 2：引入 MQ，增加了系统的复杂度
- 方案四：将 MySQL 和 redis 更新放在同一个事务中，保证强一致性
	- 缺点 1：更新时任何环节出问题，都将导致回滚或撤销
	- 缺点 2：如果网络出现超时，不仅可能造成数据回滚或撤销，还可能发生并发问题
- 方案五：订阅 MySQL 的 binlog 日志来更新 redis，把我们搭建的 mq 消费服务，作为 mysql 的一个 slave，订阅 Binlog，解析出更新的内容，再更新 redis
	- 缺点：单独搭建一个同步服务，引入 binlog 同步机制，成本较大

### Redis 分片集群是如何分片的？有什么好处？

当 Redis 的缓存数据量大到一台服务器无法缓存时，就需要使用 Redis 切片集群（Redis Cluster）方案，它将数据分布在不同的服务器上，以此来降低对单主节点的依赖，从而提高 Redis 的读写性能。

Redis Cluster 使用哈希槽（Hash Slot）来处理数据和节点的映射关系。

在 Redis Cluster 方案中，一个切片集群有 16384 个哈希槽，这些哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中，具体执行过程分为两大步：

- 根据键值对的 key，按照 CRC16 算法[1]计算一个 16bit 的值
- 用 16bit 的值对 16384 取模，得到 [0,16384) 范围内的模数，每个模数代表相应编号的哈希槽，通过哈希槽找到所属的节点

## 参考

1. Cyclic redundancy check：https://en.wikipedia.org/wiki/Cyclic_redundancy_check
