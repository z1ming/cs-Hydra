# Redis 面试题

## 数据结构

### Redis 数据结构有哪些？

Redis 常见的有 5 种数据结构：

1. String（字符串）：SDS。缓存对象、常规计数、分布式锁、共享 session 等
2. Hash（哈希）：压缩列表或哈希表 -> listpack。缓存对象、购物车
3. List（列表）：双向链表和压缩列表 -> quicklist。消息队列
   - 问题 1：生产者需要自行实现全局唯一 ID
   - 问题 2：不能以消费组形式消费数据
4. Set（集合）：哈希表或整数集合。聚合计算（交集、并集、差集），点赞、共同关注、抽奖
5. ZSet（有序集合）：压缩列表或跳表 -> listpack。排序场景，比如排行榜、电话和姓名等

后面新增了 4 种：BitMap（2.2 版新增）、HyperLogLog（2.8 版新增）、GEO（3.2 版新增）、Stream（5.0 版新增）。

### 用什么结构实现延迟消息队列？

常见延迟消息场景：

- 淘宝购物车未付款订单 24 小时后自动取消
- 打车时长时间没有车主接单，平台取消订单并告诉你暂时没有车主接单
- 点外卖时，如果商家 10 分钟还没有接单，就会自动取消接单



## 高可用

### 缓存雪崩是什么？如何解决？

缓存雪崩是指大量请求不经过缓存，直接查询数据库，导致数据库压力骤增，进而发生宕机等故障，从而造成连锁反应，造成整个系统崩溃。

造成缓存雪崩的原因和解决办法：

- 大量缓存同时过期，缓存都未命中
	- 设置均匀过期时间：如果要给缓存设置过期时间，尽量避免将大量的数据设置为同一个过期时间。可以在设置缓存时间时，给过期时间添加一个随机数，这样就保证数据不会在同一时间过期
	- 互斥锁：当业务线程在处理用户请求时，如果发现访问的数据不在 Redis 里，就加一个互斥锁，保证同一时间只能有一个请求在构建缓存（从数据库读取数据，再将数据更新到 Redis 里），当缓存构建完成后再释放锁。未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么直接返回空值或默认值
	- 后台更新缓存：业务线程不再负责更新缓存，缓存也不设置有效期，让缓存”永久有效“，并将更新缓存的工作由后台线程实时更新
- redis 故障
	- 熔断机制：直接启用服务的熔断机制，暂停业务方对缓存服务的访问，直接返回错误，不再继续访问数据库，从而降低对数据库的访问压力，保证数据库系统的正常运行，等 Redis 恢复正常后，再允许业务应用访问缓存服务。熔断机制保护了数据库的正常访问，但是暂停了业务访问缓存。
	- 构建 Redis 缓存高可用集群：通过主从节点的方式构建 Redis 缓存高可用集群。如果 Redis 缓存的主节点故障宕机，从节点可以切换为主节点，继续提供缓存服务，避免了由于 Redis 故障宕机从而导致的缓存雪崩问题

### 多级缓存如何保证数据一致性？

- 方案一：通过 redis 过期时间更新缓存，MySQL 数据库更新不会触发 redis 更新，只有当 redis key 过期后才会重新加载
	- 缺点 1：数据不一致的时间较长，会造成脏数据
	- 缺点 2：完全依赖过期时间，过期时间太短缓存更新太频繁，太长容易有长时间的更新延迟
- 方案二：在方案一的基础上，用 key 的过期时间做兜底，在更新 MySQL 的同时也会更新 redis。
	- 缺点：如果 MySQL 更新成功，redis 更新失败，则会出现和方案一一样的问题
- 方案三：在方案二的基础上，使用消息队列，异步更新 redis
	- 缺点 1：解决不了时序的问题，如果多个业务实例同时更新同一条数据，数据更新的先后顺序可能会乱
	- 缺点 2：引入 MQ，增加了系统的复杂度
- 方案四：将 MySQL 和 redis 更新放在同一个事务中，保证强一致性
	- 缺点 1：更新时任何环节出问题，都将导致回滚或撤销
	- 缺点 2：如果网络出现超时，不仅可能造成数据回滚或撤销，还可能发生并发问题
- 方案五：订阅 MySQL 的 binlog 日志来更新 redis，把我们搭建的 mq 消费服务，作为 mysql 的一个 slave，订阅 Binlog，解析出更新的内容，再更新 redis
	- 缺点：单独搭建一个同步服务，引入 binlog 同步机制，成本较大
